#ifndef SCALA_LEXER_BYTECODEBUFFER_H
#define SCALA_LEXER_BYTECODEBUFFER_H

#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <utility>
#include <stdexcept>

#include "Instructions.h"
#include "semantic/tools/datatype.h"

/**
 * BytecodeBuffer - buffer for generating JVM bytecode with label support
 *
 * Features:
 * - Emit individual opcodes and operands
 * - Forward and backward jump handling with labels
 * - Smart emit methods for common patterns
 * - Automatic label resolution before finalization
 */
class BytecodeBuffer {
private:
    std::vector<uint8_t> buffer;

    // Label management for jumps
    std::map<std::string, int32_t> labels;  // label -> offset in buffer

    // Pending forward jumps: position in buffer where offset should be written, and target label
    std::vector<std::pair<int32_t, std::string>> pendingJumps;

    // Track max stack depth for Code attribute
    int16_t currentStack = 0;
    int16_t maxStack = 0;

    void updateMaxStack(int16_t delta);

public:
    BytecodeBuffer() = default;

    // ==================== Basic Emit ====================

    /**
     * Emit a single-byte opcode with no operands
     */
    void emit(Instruction op);

    /**
     * Emit opcode with 1-byte operand
     */
    void emit(Instruction op, uint8_t operand);

    /**
     * Emit opcode with 2-byte operand (big-endian)
     */
    void emit(Instruction op, uint16_t operand);

    /**
     * Emit opcode with two separate 1-byte operands
     */
    void emit(Instruction op, uint8_t op1, uint8_t op2);

    /**
     * Emit raw byte
     */
    void emitByte(uint8_t b);

    /**
     * Emit 2 bytes (big-endian)
     */
    void emitShort(uint16_t value);

    /**
     * Emit 4 bytes (big-endian)
     */
    void emitInt(uint32_t value);

    // ==================== Branch Instructions ====================

    /**
     * Emit a branch instruction with target label
     * The offset will be resolved later when resolveLabels() is called
     */
    void emitBranch(Instruction op, const std::string& label);

    /**
     * Define a label at current position
     */
    void emitLabel(const std::string& label);

    /**
     * Resolve all pending forward jumps
     * Must be called before getBytes()
     */
    void resolveLabels();

    // ==================== Smart Emit Methods ====================

    /**
     * Emit optimal instruction to push an int constant
     * Uses ICONST_x, BIPUSH, SIPUSH, or LDC as appropriate
     */
    void emitIconst(int32_t value, class ConstantPoolBuilder* pool = nullptr);

    /**
     * Emit load instruction for given type and local variable slot
     */
    void emitLoad(const DataType& type, uint16_t slot);

    /**
     * Emit store instruction for given type and local variable slot
     */
    void emitStore(const DataType& type, uint16_t slot);

    /**
     * Emit appropriate return instruction for given type
     */
    void emitReturn(const DataType& type);

    /**
     * Emit array load instruction for given element type
     */
    void emitArrayLoad(const DataType& elementType);

    /**
     * Emit array store instruction for given element type
     */
    void emitArrayStore(const DataType& elementType);

    // ==================== Stack Tracking ====================

    /**
     * Manually adjust stack tracking (for complex operations)
     */
    void adjustStack(int16_t delta);

    /**
     * Get maximum stack depth reached
     */
    uint16_t getMaxStack() const { return static_cast<uint16_t>(maxStack); }

    /**
     * Reset stack tracking (e.g., at method start)
     */
    void resetStack() { currentStack = 0; maxStack = 0; }

    // ==================== Buffer Access ====================

    /**
     * Get current position in buffer
     */
    size_t position() const { return buffer.size(); }

    /**
     * Get the generated bytecode
     * Call resolveLabels() first if using branches!
     */
    std::vector<uint8_t> getBytes() const { return buffer; }

    /**
     * Get bytecode length
     */
    size_t size() const { return buffer.size(); }

    /**
     * Check if a label exists
     */
    bool hasLabel(const std::string& label) const;

    /**
     * Generate unique label name
     */
    std::string generateLabel(const std::string& prefix = "L");

private:
    int labelCounter = 0;
};

#endif // SCALA_LEXER_BYTECODEBUFFER_H
